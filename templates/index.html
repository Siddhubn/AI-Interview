<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Virtual Interviewer</title>
    
    <!-- MediaPipe Libraries for Proctoring -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    
    <!-- Fonts and Styling -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #111827; }
        .fade-in { animation: fadeIn 0.5s ease-in-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        .pulse { animation: pulse 1.5s infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
        
        .video-container {
            position: relative;
            background-color: #1F2937;
            overflow: hidden;
            width: 100%;
            height: 100%;
        }
        .video-container video, .video-container canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }
        .proctor-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: rgba(220, 38, 38, 0.5);
            color: white;
            font-size: 2rem;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease-in-out;
        }
        .proctor-overlay.visible { opacity: 1; }
    </style>
</head>
<body class="text-gray-200 flex items-center justify-center min-h-screen">

    <!-- Main Container -->
    <div id="main-container" class="w-full h-screen p-4 flex flex-col fade-in">
        <header class="flex-shrink-0 flex justify-between items-center pb-4">
            <h1 class="text-xl font-bold">AI Virtual Interview</h1>
            <div id="proctor-status-container" class="flex items-center gap-2">
                <span id="proctor-status-indicator" class="h-3 w-3 rounded-full bg-gray-500" title="Proctoring Inactive"></span>
                <span id="proctor-status-text" class="text-sm font-medium">Proctoring Offline</span>
            </div>
        </header>

        <!-- Interview Screen -->
        <main id="interview-screen" class="flex-grow grid grid-cols-1 md:grid-cols-2 gap-4 min-h-0 hidden">
            <!-- AI Interviewer Side -->
            <div class="video-container rounded-lg flex flex-col justify-between p-6">
                <div class="flex-shrink-0">
                    <h2 class="text-2xl font-bold">AI Interviewer</h2>
                </div>
                <div class="flex-grow flex items-center justify-center">
                    <p id="question-text" class="text-2xl lg:text-3xl font-medium text-center text-gray-100 max-w-lg"></p>
                </div>
                <div class="flex-shrink-0 h-10">
                    <div id="ai-status" class="bg-indigo-500 text-white rounded-full px-4 py-1 inline-flex items-center gap-2">
                        <span class="w-3 h-3 bg-white rounded-full pulse"></span>
                        <span id="ai-status-text">Initializing...</span>
                    </div>
                </div>
            </div>
            <!-- Candidate Side -->
            <div class="flex flex-col gap-4">
                <div class="video-container rounded-lg flex-grow">
                    <video class="input_video" style="display: none;" autoplay muted playsinline></video>
                    <canvas class="output_canvas"></canvas>
                    <div id="proctor-warning-overlay" class="proctor-overlay rounded-lg">
                        <span id="proctor-warning-text"></span>
                    </div>
                    <div class="absolute top-4 right-4 bg-black bg-opacity-50 text-white px-3 py-1 rounded-full text-sm font-bold" id="timer-display">02:00</div>
                    <div class="absolute bottom-4 right-4 bg-black bg-opacity-50 text-white px-3 py-1 rounded-full text-sm">
                        Candidate
                    </div>
                </div>
                <div class="flex-shrink-0">
                    <textarea id="answer-textarea" class="w-full h-24 p-3 bg-gray-900 border border-gray-700 rounded-lg text-gray-300" placeholder="Your transcribed answer will appear here..." readonly></textarea>
                </div>
            </div>
        </main>
        
        <!-- Controls -->
        <footer id="controls" class="flex-shrink-0 pt-4 flex justify-center items-center gap-4 h-20 hidden">
             <button id="record-btn" class="bg-indigo-600 text-white font-semibold py-3 px-6 rounded-lg hover:bg-indigo-700 transition flex items-center justify-center disabled:bg-gray-600 disabled:cursor-not-allowed">
                Start Answering
            </button>
            <button id="next-btn" class="bg-gray-700 text-white font-semibold py-3 px-6 rounded-lg hover:bg-gray-600 transition disabled:bg-gray-800 disabled:text-gray-500 disabled:cursor-not-allowed hidden">
                Next Question
            </button>
        </footer>
    </div>
    
    <!-- Setup Modal -->
    <div id="setup-modal" class="absolute inset-0 bg-black bg-opacity-75 flex items-center justify-center p-4 z-50 fade-in">
        <div class="bg-gray-800 rounded-2xl shadow-lg p-8 w-full max-w-lg space-y-6">
             <h2 class="text-3xl font-bold text-center">Interview Setup</h2>
             <div>
                <label class="block text-sm font-medium text-gray-400 mb-2">1. Select Job Role</label>
                <div class="flex flex-wrap gap-2 mb-3">
                    <button class="job-role-btn bg-gray-700 text-gray-300 text-sm font-semibold py-1 px-3 rounded-full hover:bg-indigo-500 hover:text-white transition" data-role="frontend">Frontend</button>
                    <button class="job-role-btn bg-gray-700 text-gray-300 text-sm font-semibold py-1 px-3 rounded-full hover:bg-indigo-500 hover:text-white transition" data-role="backend">Backend</button>
                    <button class="job-role-btn bg-gray-700 text-gray-300 text-sm font-semibold py-1 px-3 rounded-full hover:bg-indigo-500 hover:text-white transition" data-role="data-scientist">Data Scientist</button>
                    <button class="job-role-btn bg-gray-700 text-gray-300 text-sm font-semibold py-1 px-3 rounded-full hover:bg-indigo-500 hover:text-white transition" data-role="devops">DevOps</button>
                </div>
                <textarea id="job-req-input" placeholder="Or paste a custom job description..." class="w-full h-24 p-3 bg-gray-900 border border-gray-700 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 transition"></textarea>
            </div>
             <div>
                <label class="block text-sm font-medium text-gray-400 mb-2">2. Upload Resume</label>
                <div class="flex items-center gap-4">
                    <label class="bg-gray-700 text-gray-300 font-semibold py-2 px-4 rounded-lg hover:bg-gray-600 transition cursor-pointer">
                        <span>Choose File</span>
                        <input type="file" id="resume-file-input" class="hidden" accept=".pdf,.docx">
                    </label>
                    <span id="file-name" class="text-sm text-gray-500 truncate">No file selected...</span>
                </div>
            </div>
            <button id="start-btn" class="w-full bg-indigo-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-indigo-700 disabled:bg-gray-500 disabled:cursor-not-allowed transition" disabled>
                Start Interview
            </button>
        </div>
    </div>

    <!-- Final Score Modal -->
    <div id="end-modal" class="absolute inset-0 bg-black bg-opacity-75 flex-col items-center justify-center p-4 z-50 hidden">
        <div class="bg-gray-800 rounded-2xl shadow-lg p-8 w-full max-w-lg space-y-4 fade-in">
             <h2 class="text-3xl font-bold text-center">Interview Complete</h2>
             <div class="text-center">
                <p>Your performance report is being generated.</p>
                <p id="download-status" class="text-indigo-400 font-semibold mt-2">Please wait...</p>
             </div>
             <p class="text-2xl font-bold my-2 p-4 bg-gray-900 rounded-lg text-center" id="average-score-text"></p>
             <button id="restart-btn" class="w-full bg-indigo-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-indigo-700 transition">
                Start New Interview
             </button>
        </div>
    </div>
    
    <script type="module">
        // --- Element Selectors ---
        const setupModal = document.getElementById('setup-modal');
        const endModal = document.getElementById('end-modal');
        const interviewScreen = document.getElementById('interview-screen');
        const controlsFooter = document.getElementById('controls');
        const jobReqInput = document.getElementById('job-req-input');
        const resumeFileInput = document.getElementById('resume-file-input');
        const fileNameSpan = document.getElementById('file-name');
        const startBtn = document.getElementById('start-btn');
        const questionTextEl = document.getElementById('question-text');
        const aiStatusText = document.getElementById('ai-status-text');
        const recordBtn = document.getElementById('record-btn');
        const nextBtn = document.getElementById('next-btn');
        const restartBtn = document.getElementById('restart-btn');
        const averageScoreEl = document.getElementById('average-score-text');
        const answerTextarea = document.getElementById('answer-textarea');
        const timerDisplay = document.getElementById('timer-display');
        const downloadStatus = document.getElementById('download-status');
        
        const videoElement = document.querySelector('.input_video');
        const canvasElement = document.querySelector('.output_canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const proctorStatusIndicator = document.getElementById('proctor-status-indicator');
        const proctorStatusText = document.getElementById('proctor-status-text');
        const proctorWarningOverlay = document.getElementById('proctor-warning-overlay');
        const proctorWarningText = document.getElementById('proctor-warning-text');

        // --- State Variables ---
        let questions = [];
        let interviewResults = [];
        let currentQuestionIndex = 0;
        let recognition;
        let isRecording = false;
        let voices = [];
        let faceMesh;
        let camera;
        let focusWarningTimeout, multiFaceTimeout;
        let proctoringFlags = [];
        let isProctoringReady = false;
        let resumeTextContent = "";
        let jobRequirementsText = "";
        let answerTimerInterval;
        let answerTimeLeft = 120;
        let accumulatedTranscript = "";

        // --- Proctoring Logic ---
        function onResults(results) {
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
            
            if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 1) {
                if (!multiFaceTimeout) {
                    multiFaceTimeout = setTimeout(() => {
                        proctorWarningText.textContent = "alert";
                        proctorWarningOverlay.classList.add('visible');
                        proctoringFlags.push(`Q${currentQuestionIndex + 1}: Multiple faces detected`);
                    }, 1000);
                }
                canvasCtx.restore();
                return;
            } else {
                 clearTimeout(multiFaceTimeout);
                 multiFaceTimeout = null;
                 if(proctorWarningText.textContent === "alert") {
                    proctorWarningOverlay.classList.remove('visible');
                 }
            }

            if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                const landmarks = results.multiFaceLandmarks[0];
                let isMalpracticeDetected = false;
                
                const nose = landmarks[1];
                if (nose.x < 0.3 || nose.x > 0.7 || nose.y < 0.25 || nose.y > 0.75) isMalpracticeDetected = true;
                
                const foreheadTop = landmarks[10], chin = landmarks[152], leftCheek = landmarks[234], rightCheek = landmarks[454];
                if(foreheadTop && chin && leftCheek && rightCheek) {
                    if ((Math.abs(chin.y - foreheadTop.y) / Math.abs(rightCheek.x - leftCheek.x)) < 1.3) isMalpracticeDetected = true;
                }
                
                if (isMalpracticeDetected) {
                    if (!focusWarningTimeout) {
                        focusWarningTimeout = setTimeout(() => {
                           if (proctorWarningText.textContent !== 'alert') {
                                proctorWarningText.textContent = "focus";
                                proctorWarningOverlay.classList.add('visible');
                           }
                           proctoringFlags.push(`Q${currentQuestionIndex + 1}: Lack of focus`);
                        }, 1500);
                    }
                } else {
                    clearTimeout(focusWarningTimeout);
                    focusWarningTimeout = null;
                    if (proctorWarningText.textContent === "focus") {
                        proctorWarningOverlay.classList.remove('visible');
                    }
                }
            }
            canvasCtx.restore();
        }

        function startProctoring() {
            return new Promise(async (resolve, reject) => {
                proctorStatusText.textContent = "Initializing Camera...";
                proctorStatusIndicator.classList.replace('bg-gray-500', 'bg-yellow-500');
                try {
                    faceMesh = new FaceMesh({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`});
                    faceMesh.setOptions({ maxNumFaces: 1, refineLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
                    faceMesh.onResults(onResults);
                    await faceMesh.initialize();
                    const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                    videoElement.srcObject = stream;
                    videoElement.onloadedmetadata = async () => {
                        camera = new Camera(videoElement, { onFrame: async () => await faceMesh.send({image: videoElement}), width: 640, height: 480 });
                        await camera.start();
                        isProctoringReady = true;
                        proctorStatusIndicator.classList.replace('bg-yellow-500', 'bg-green-500');
                        proctorStatusText.textContent = "Proctoring Active";
                        resolve();
                    };
                } catch (err) {
                    stopProctoring();
                    reject(err);
                }
            });
        }

        function stopProctoring() {
             isProctoringReady = false;
            clearTimeout(focusWarningTimeout);
            clearTimeout(multiFaceTimeout);
            if (camera) camera.stop();
            if (videoElement.srcObject) videoElement.srcObject.getTracks().forEach(track => track.stop());
            if (faceMesh) faceMesh.close();
            proctorStatusIndicator.classList.replace('bg-green-500', 'bg-gray-500');
            proctorStatusIndicator.classList.replace('bg-yellow-500', 'bg-gray-500');
            proctorStatusText.textContent = "Proctoring Offline";
        }
        
        // --- Setup and UI Logic ---
        const jobRoleButtons = document.querySelectorAll('.job-role-btn');
        const jobDescriptions = {
            'frontend': 'Seeking a Frontend Developer with expertise in HTML, CSS, JavaScript, and modern frameworks like React or Vue.',
            'backend': 'Hiring a Backend Developer proficient in Python, database management, and API development.',
            'data-scientist': 'Looking for a Data Scientist skilled in machine learning, statistical analysis, and Python.',
            'devops': 'We need a DevOps Engineer experienced with CI/CD pipelines, cloud infrastructure, and containerization.'
        };
        jobRoleButtons.forEach(button => {
            button.addEventListener('click', () => {
                const role = button.dataset.role;
                jobReqInput.value = jobDescriptions[role];
                jobRoleButtons.forEach(btn => {
                    btn.classList.remove('bg-indigo-500', 'text-white');
                    btn.classList.add('bg-gray-700', 'text-gray-300');
                });
                button.classList.add('bg-indigo-500', 'text-white');
                checkIfReady();
            });
        });
        resumeFileInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            fileNameSpan.textContent = `Uploading ${file.name}...`;
            const formData = new FormData();
            formData.append('resume', file);
            try {
                const response = await fetch('/extract_resume_text', { method: 'POST', body: formData });
                const data = await response.json();
                if (!response.ok) throw new Error(data.error);
                resumeTextContent = data.resume_text;
                fileNameSpan.textContent = `✓ ${file.name}`;
            } catch (error) {
                fileNameSpan.textContent = `✗ Error`;
                showError(error.message);
            } finally {
                checkIfReady();
            }
        });
        function checkIfReady() {
            jobRequirementsText = jobReqInput.value.trim();
            const jobReqFilled = jobRequirementsText.length > 0;
            const resumeFilled = resumeTextContent.length > 0;
            startBtn.disabled = !(jobReqFilled && resumeFilled);
        }
        jobReqInput.addEventListener('input', checkIfReady);
        function showError(message) {
            alert(`Error: ${message}`);
        }
        
        // --- Speech, Recording, and Timer Logic ---
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        if(SpeechRecognition) {
            recognition = new SpeechRecognition();
            recognition.continuous = true;
            recognition.interimResults = true;
            
            recognition.onresult = (event) => {
                let finalTranscript = '';
                for (let i = event.resultIndex; i < event.results.length; ++i) {
                     if (event.results[i].isFinal) {
                        accumulatedTranscript += event.results[i][0].transcript.trim() + '. ';
                    }
                }
                answerTextarea.value = accumulatedTranscript;
            };
            
            recognition.onerror = (event) => {
                 if (event.error !== 'no-speech' && event.error !== 'aborted') {
                    showError(`Speech recognition error: ${event.error}`);
                 }
            };
        }
        
        function loadVoices() { voices = window.speechSynthesis.getVoices(); }
        loadVoices();
        if (window.speechSynthesis.onvoiceschanged !== undefined) window.speechSynthesis.onvoiceschanged = loadVoices;

        function speakText(text) {
             return new Promise((resolve) => {
                aiStatusText.textContent = "Speaking...";
                if ('speechSynthesis' in window) {
                    const utterance = new SpeechSynthesisUtterance(text);
                    utterance.onend = resolve;
                    utterance.onerror = resolve;
                    let selectedVoice = voices.find(v => v.lang.startsWith('en') && (v.name.includes('Google') || v.name.includes('Natural')));
                    if (!selectedVoice) selectedVoice = voices.find(v => v.lang.startsWith('en'));
                    if (selectedVoice) utterance.voice = selectedVoice;
                    utterance.rate = 0.95;
                    window.speechSynthesis.speak(utterance);
                } else resolve();
            });
        }

        function startTimer() {
            answerTimeLeft = 120;
            timerDisplay.textContent = "02:00";
            timerDisplay.classList.remove('text-red-500');
            answerTimerInterval = setInterval(() => {
                answerTimeLeft--;
                const minutes = Math.floor(answerTimeLeft / 60).toString().padStart(2, '0');
                const seconds = (answerTimeLeft % 60).toString().padStart(2, '0');
                timerDisplay.textContent = `${minutes}:${seconds}`;
                if (answerTimeLeft <= 10) {
                     timerDisplay.classList.add('text-red-500');
                }
                if (answerTimeLeft <= 0) {
                    stopRecording();
                }
            }, 1000);
        }

        function startRecording() {
            if (recognition && !isRecording) {
                isRecording = true;
                aiStatusText.textContent = "Listening...";
                recordBtn.textContent = "Finish Answering";
                recordBtn.classList.replace('bg-indigo-600', 'bg-red-600');
                recordBtn.disabled = false;
                answerTextarea.value = "";
                accumulatedTranscript = "";
                recognition.start();
                startTimer();
            }
        }

        function stopRecording() {
            if (isRecording) {
                isRecording = false;
                clearInterval(answerTimerInterval);
                aiStatusText.textContent = "Evaluating...";
                recordBtn.textContent = "Start Answering";
                recordBtn.classList.replace('bg-red-600', 'bg-indigo-600');
                recordBtn.disabled = true;
                if(recognition) recognition.stop();
                submitForScoring();
            }
        }

        // --- Core Interview Flow ---
        async function runQuestionCycle() {
            if (currentQuestionIndex >= questions.length) {
                showFinalScore();
                return;
            }
            aiStatusText.textContent = "Thinking...";
            questionTextEl.textContent = "";
            nextBtn.style.display = 'none';
            recordBtn.style.display = 'flex';
            recordBtn.disabled = true;
            answerTextarea.value = "";

            const formalQuestion = questions[currentQuestionIndex];
            
            try {
                const casualResponse = await fetch('/make_casual', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ question: formalQuestion })
                });
                const casualData = await casualResponse.json();
                const casualQuestion = casualData.casual_question || formalQuestion;

                questionTextEl.textContent = casualQuestion;
                await speakText(casualQuestion);
                aiStatusText.textContent = "Ready to answer";
                recordBtn.disabled = false;
            } catch (e) {
                questionTextEl.textContent = formalQuestion;
                await speakText(formalQuestion);
                aiStatusText.textContent = "Ready to answer";
                recordBtn.disabled = false;
            }
        }
        
        async function submitForScoring() {
            const answer = answerTextarea.value.trim();
             if(!answer) {
                interviewResults.push({ question: questions[currentQuestionIndex], answer: "No answer recorded.", score: 0, feedback: "No answer was recorded." });
                aiStatusText.textContent = "No answer detected.";
            } else {
                try {
                    const response = await fetch('/score_answer', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ question: questions[currentQuestionIndex], answer: answer })
                    });
                    const data = await response.json();
                    if(!response.ok) throw new Error(data.error);
                    interviewResults.push({ question: questions[currentQuestionIndex], answer: answer, score: data.score, feedback: data.feedback });
                    aiStatusText.textContent = `Score: ${data.score}/10`;
                } catch(error) {
                     interviewResults.push({ question: questions[currentQuestionIndex], answer: answer, score: 0, feedback: "Scoring failed." });
                     aiStatusText.textContent = "Scoring Error";
                }
            }
            recordBtn.style.display = 'none';
            nextBtn.style.display = 'flex';
            nextBtn.disabled = false;
        };

        async function showFinalScore() {
            stopProctoring();
            interviewScreen.classList.add('hidden');
            controlsFooter.classList.add('hidden');
            endModal.style.display = 'flex';
            
            let totalScore = 0;
            interviewResults.forEach(result => totalScore += result.score);
            const averageScore = interviewResults.length > 0 ? (totalScore / interviewResults.length).toFixed(1) : 0;
            averageScoreEl.textContent = `Final Average Score: ${averageScore} / 10`;

            try {
                const response = await fetch('/generate_final_scorecard', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        job_requirements: jobRequirementsText,
                        interview_results: interviewResults,
                        proctoring_flags: proctoringFlags
                    })
                });

                if (!response.ok) throw new Error("Failed to generate PDF report.");

                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = 'Candidate_Performance_Report.pdf';
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                a.remove();
                downloadStatus.textContent = "Report downloaded successfully!";

            } catch(error) {
                showError(error.message);
                downloadStatus.textContent = "Could not download report.";
            }
        }

        // --- Event Listeners ---
        startBtn.addEventListener('click', async () => {
            if (!jobRequirementsText || !resumeTextContent) {
                showError('Please fill all fields and upload a resume.');
                return;
            }
            setupModal.style.display = 'none';
            interviewScreen.classList.remove('hidden');
            controlsFooter.classList.remove('hidden');
            
            try {
                await startProctoring();
                
                const response = await fetch('/generate_questions', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        job_requirements: jobRequirementsText, 
                        candidate_skills: resumeTextContent
                    }),
                });
                const data = await response.json();
                if (!response.ok) throw new Error(data.error);
                questions = data.questions;

                runQuestionCycle();

            } catch (error) {
                showError(error.message || "Setup failed.");
                location.reload();
            }
        });
        
        recordBtn.addEventListener('click', () => {
             if (!isRecording) startRecording();
             else stopRecording();
        });

        nextBtn.addEventListener('click', () => {
            currentQuestionIndex++;
            runQuestionCycle();
        });
        
        restartBtn.addEventListener('click', () => location.reload());
    </script>
</body>
</html>

